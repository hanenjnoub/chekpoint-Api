import React, { useMemo } from 'react';
export const $ACTION = Symbol('ACTION');
export const $PREV_STATE = Symbol('PREV_STATE');
export const $TRANSITIONS = Symbol('TRANSITIONS');
export const DEBUG_TRANSITIONS = Symbol('DEBUG_TRANSITIONS');
export const DEBUG_COMMAND = Symbol('DEBUG_COMMAND');
export const DEBUG_ID = Symbol('DEBUG_ID');
const DEBUG_TRIGGER_TRANSITIONS = Symbol('DEBUG_TRIGGER_TRANSITIONS');
export const createStates = (states) => {
    const statesWithState = {};
    for (let state in states) {
        // @ts-ignore
        statesWithState[state] = (...params) => (Object.assign(Object.assign({}, states[state](...params)), { state }));
    }
    return statesWithState;
};
export const createActions = (actions) => {
    return (dispatch) => useMemo(() => {
        const actionsWithType = {};
        for (let type in actions) {
            // @ts-ignore
            actionsWithType[type] = (...params) => dispatch(Object.assign(Object.assign({}, actions[type](...params)), { type }));
        }
        return actionsWithType;
    }, [dispatch]);
};
export function transition(state, action, transitions) {
    let newState = state;
    // @ts-ignore
    const debugId = state[DEBUG_ID];
    // @ts-ignore
    if (transitions[state.state] && transitions[state.state][action.type]) {
        // @ts-ignore
        newState = transitions[state.state][action.type](state, action);
        // @ts-ignore
        newState[$ACTION] = action;
        // @ts-ignore
        action[$ACTION] && newState !== state && action[$ACTION](debugId, false);
        // @ts-ignore
        newState[$PREV_STATE] = state;
        // @ts-ignore
        delete state[$PREV_STATE];
        // @ts-ignore
        delete state[$ACTION];
    }
    else {
        // @ts-ignore
        action[$ACTION] && action[$ACTION](debugId, true);
    }
    if (debugId) {
        // @ts-ignore
        newState[DEBUG_ID] = debugId;
        // @ts-ignore
        newState[DEBUG_TRANSITIONS] = transitions;
    }
    return newState;
}
export function useEnter(state, states, effect, deps = []) {
    // @ts-ignore
    const statesList = Array.isArray(states) ? states : [states];
    const currentState = state;
    const isMatch = statesList.includes(state.state);
    // @ts-ignore
    return React.useEffect(() => isMatch && effect(currentState), deps.concat(isMatch));
}
export function useTransition() {
    const state = arguments[0];
    const transitions = arguments[1];
    const cb = arguments[2] || arguments[1];
    const deps = Array.isArray(arguments[arguments.length - 1]) ? arguments[arguments.length - 1] : [];
    if (typeof transitions === 'function') {
        return React.useEffect(() => cb(state, state[$ACTION], state[$PREV_STATE]), deps.concat(state));
    }
    return React.useEffect(() => {
        const transitionsList = Array.isArray(transitions) ? transitions : [transitions];
        const currentState = state;
        const prevState = state[$PREV_STATE];
        const action = state[$ACTION];
        const transition = `${prevState === null || prevState === void 0 ? void 0 : prevState.state} => ${action === null || action === void 0 ? void 0 : action.type} => ${currentState.state}`;
        if (transitionsList.includes(transition)) {
            return cb(currentState, action, prevState);
        }
    }, deps.concat(state));
}
export function match() {
    const state = arguments[0];
    const matches = arguments[1];
    const _ = arguments[2];
    if (_) {
        return (matches[state.state] || _)(state);
    }
    return matches[state.state](state);
}
export function matchProp() {
    const state = arguments[0];
    const prop = arguments[1];
    // @ts-ignore
    return prop in state ? state : undefined;
}
export const managerContext = React.createContext(null);
// We have to type as any as States<any, any> throws error not matching
// the explicit context
export const useDevtools = (id, reducer) => {
    const manager = React.useContext(managerContext);
    // We allow using the hook without having the wrapping devtool
    if (!manager) {
        return reducer;
    }
    const [state, dispatch] = reducer;
    React.useEffect(() => () => manager.dispose(id), [id, manager]);
    // @ts-ignore
    reducer[0][DEBUG_ID] = id;
    // @ts-ignore
    reducer[0][DEBUG_COMMAND] = (command) => {
        manager.onMessage(id, {
            type: 'command',
            command,
        });
    };
    reducer[1] = (action) => {
        action[$ACTION] = (id, isIgnored) => {
            manager.onMessage(id, {
                type: 'dispatch',
                action,
                ignored: isIgnored,
            });
        };
        dispatch(action);
        if (action.type === DEBUG_TRIGGER_TRANSITIONS) {
            manager.onMessage(id, {
                type: 'transitions',
                // @ts-ignore
                transitions: state[DEBUG_TRANSITIONS],
            });
            return;
        }
    };
    React.useEffect(() => {
        manager.onMessage(id, {
            type: 'state',
            state,
            // @ts-ignore
            transitions: state[DEBUG_TRANSITIONS],
            triggerTransitions: () => {
                // We dispatch to ensure the transition is run
                reducer[1]({
                    type: DEBUG_TRIGGER_TRANSITIONS,
                });
            },
        });
    }, [id, manager, state]);
    return reducer;
};
//# sourceMappingURL=index.js.map