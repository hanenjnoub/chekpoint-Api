"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Manager = void 0;
function debounce(func, timeout) {
    let timer;
    return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => {
            func(...args);
        }, timeout);
    };
}
class Manager {
    constructor() {
        this.subscriptions = [];
        this.states = {};
        this.notify = debounce(() => {
            this.subscriptions.forEach((cb) => cb(this.states));
        }, 100);
    }
    ensureStates(id) {
        if (!this.states[id]) {
            this.states[id] = {
                isMounted: true,
                history: [],
                // @ts-ignore
                transitions: {},
                triggerTransitions: () => { },
            };
        }
    }
    onMessage(id, message) {
        this.ensureStates(id);
        switch (message.type) {
            case 'state': {
                // You might trigger dispatches before the devtools has sent its initial state
                const isFirstState = this.states[id].history.filter((item) => item.type === 'state').length === 0;
                this.states = Object.assign(Object.assign({}, this.states), { [id]: Object.assign(Object.assign({}, this.states[id]), { isMounted: true, history: isFirstState
                            ? [
                                ...this.states[id].history,
                                {
                                    type: 'state',
                                    state: message.state,
                                },
                            ]
                            : [
                                {
                                    type: 'state',
                                    state: message.state,
                                },
                                ...this.states[id].history,
                            ], triggerTransitions: message.triggerTransitions }) });
                break;
            }
            case 'transitions': {
                this.states = Object.assign(Object.assign({}, this.states), { [id]: Object.assign(Object.assign({}, this.states[id]), { transitions: message.transitions }) });
                break;
            }
            case 'dispatch': {
                this.states = Object.assign(Object.assign({}, this.states), { [id]: Object.assign(Object.assign({}, this.states[id]), { history: [
                            {
                                type: 'action',
                                action: message.action,
                                ignored: message.ignored,
                            },
                            ...this.states[id].history,
                        ] }) });
                break;
            }
        }
        this.notify();
    }
    dispose(id) {
        this.states = Object.assign(Object.assign({}, this.states), { [id]: Object.assign(Object.assign({}, this.states[id]), { isMounted: false }) });
        this.notify();
    }
    subscribe(cb) {
        this.subscriptions.push(cb);
        return () => {
            this.subscriptions.splice(this.subscriptions.indexOf(cb), 1);
        };
    }
}
exports.Manager = Manager;
//# sourceMappingURL=Manager.js.map