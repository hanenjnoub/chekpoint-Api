"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useDevtools = exports.managerContext = exports.matchProp = exports.match = exports.useTransition = exports.useEnter = exports.transition = exports.createActions = exports.createStates = exports.DEBUG_ID = exports.DEBUG_COMMAND = exports.DEBUG_TRANSITIONS = exports.$TRANSITIONS = exports.$PREV_STATE = exports.$ACTION = void 0;
const tslib_1 = require("tslib");
const react_1 = tslib_1.__importStar(require("react"));
exports.$ACTION = Symbol('ACTION');
exports.$PREV_STATE = Symbol('PREV_STATE');
exports.$TRANSITIONS = Symbol('TRANSITIONS');
exports.DEBUG_TRANSITIONS = Symbol('DEBUG_TRANSITIONS');
exports.DEBUG_COMMAND = Symbol('DEBUG_COMMAND');
exports.DEBUG_ID = Symbol('DEBUG_ID');
const DEBUG_TRIGGER_TRANSITIONS = Symbol('DEBUG_TRIGGER_TRANSITIONS');
const createStates = (states) => {
    const statesWithState = {};
    for (let state in states) {
        // @ts-ignore
        statesWithState[state] = (...params) => (Object.assign(Object.assign({}, states[state](...params)), { state }));
    }
    return statesWithState;
};
exports.createStates = createStates;
const createActions = (actions) => {
    return (dispatch) => react_1.useMemo(() => {
        const actionsWithType = {};
        for (let type in actions) {
            // @ts-ignore
            actionsWithType[type] = (...params) => dispatch(Object.assign(Object.assign({}, actions[type](...params)), { type }));
        }
        return actionsWithType;
    }, [dispatch]);
};
exports.createActions = createActions;
function transition(state, action, transitions) {
    let newState = state;
    // @ts-ignore
    const debugId = state[exports.DEBUG_ID];
    // @ts-ignore
    if (transitions[state.state] && transitions[state.state][action.type]) {
        // @ts-ignore
        newState = transitions[state.state][action.type](state, action);
        // @ts-ignore
        newState[exports.$ACTION] = action;
        // @ts-ignore
        action[exports.$ACTION] && newState !== state && action[exports.$ACTION](debugId, false);
        // @ts-ignore
        newState[exports.$PREV_STATE] = state;
        // @ts-ignore
        delete state[exports.$PREV_STATE];
        // @ts-ignore
        delete state[exports.$ACTION];
    }
    else {
        // @ts-ignore
        action[exports.$ACTION] && action[exports.$ACTION](debugId, true);
    }
    if (debugId) {
        // @ts-ignore
        newState[exports.DEBUG_ID] = debugId;
        // @ts-ignore
        newState[exports.DEBUG_TRANSITIONS] = transitions;
    }
    return newState;
}
exports.transition = transition;
function useEnter(state, states, effect, deps = []) {
    // @ts-ignore
    const statesList = Array.isArray(states) ? states : [states];
    const currentState = state;
    const isMatch = statesList.includes(state.state);
    // @ts-ignore
    return react_1.default.useEffect(() => isMatch && effect(currentState), deps.concat(isMatch));
}
exports.useEnter = useEnter;
function useTransition() {
    const state = arguments[0];
    const transitions = arguments[1];
    const cb = arguments[2] || arguments[1];
    const deps = Array.isArray(arguments[arguments.length - 1]) ? arguments[arguments.length - 1] : [];
    if (typeof transitions === 'function') {
        return react_1.default.useEffect(() => cb(state, state[exports.$ACTION], state[exports.$PREV_STATE]), deps.concat(state));
    }
    return react_1.default.useEffect(() => {
        const transitionsList = Array.isArray(transitions) ? transitions : [transitions];
        const currentState = state;
        const prevState = state[exports.$PREV_STATE];
        const action = state[exports.$ACTION];
        const transition = `${prevState === null || prevState === void 0 ? void 0 : prevState.state} => ${action === null || action === void 0 ? void 0 : action.type} => ${currentState.state}`;
        if (transitionsList.includes(transition)) {
            return cb(currentState, action, prevState);
        }
    }, deps.concat(state));
}
exports.useTransition = useTransition;
function match() {
    const state = arguments[0];
    const matches = arguments[1];
    const _ = arguments[2];
    if (_) {
        return (matches[state.state] || _)(state);
    }
    return matches[state.state](state);
}
exports.match = match;
function matchProp() {
    const state = arguments[0];
    const prop = arguments[1];
    // @ts-ignore
    return prop in state ? state : undefined;
}
exports.matchProp = matchProp;
exports.managerContext = react_1.default.createContext(null);
// We have to type as any as States<any, any> throws error not matching
// the explicit context
const useDevtools = (id, reducer) => {
    const manager = react_1.default.useContext(exports.managerContext);
    // We allow using the hook without having the wrapping devtool
    if (!manager) {
        return reducer;
    }
    const [state, dispatch] = reducer;
    react_1.default.useEffect(() => () => manager.dispose(id), [id, manager]);
    // @ts-ignore
    reducer[0][exports.DEBUG_ID] = id;
    // @ts-ignore
    reducer[0][exports.DEBUG_COMMAND] = (command) => {
        manager.onMessage(id, {
            type: 'command',
            command,
        });
    };
    reducer[1] = (action) => {
        action[exports.$ACTION] = (id, isIgnored) => {
            manager.onMessage(id, {
                type: 'dispatch',
                action,
                ignored: isIgnored,
            });
        };
        dispatch(action);
        if (action.type === DEBUG_TRIGGER_TRANSITIONS) {
            manager.onMessage(id, {
                type: 'transitions',
                // @ts-ignore
                transitions: state[exports.DEBUG_TRANSITIONS],
            });
            return;
        }
    };
    react_1.default.useEffect(() => {
        manager.onMessage(id, {
            type: 'state',
            state,
            // @ts-ignore
            transitions: state[exports.DEBUG_TRANSITIONS],
            triggerTransitions: () => {
                // We dispatch to ensure the transition is run
                reducer[1]({
                    type: DEBUG_TRIGGER_TRANSITIONS,
                });
            },
        });
    }, [id, manager, state]);
    return reducer;
};
exports.useDevtools = useDevtools;
//# sourceMappingURL=index.js.map