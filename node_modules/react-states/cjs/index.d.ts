import React, { Dispatch } from 'react';
import type { Manager } from './devtools/Manager';
export declare const $ACTION: unique symbol;
export declare const $PREV_STATE: unique symbol;
export declare const $TRANSITIONS: unique symbol;
export declare const DEBUG_TRANSITIONS: unique symbol;
export declare const DEBUG_COMMAND: unique symbol;
export declare const DEBUG_ID: unique symbol;
export interface IState {
    state: string;
    [$ACTION]?: IAction;
    [$TRANSITIONS]?: TReadableTransition<any>;
}
export declare const createStates: <T extends Record<string, (...params: any[]) => Record<string, unknown>>>(states: T) => { [U in keyof T]: (...params: Parameters<T[U]>) => ReturnType<T[U]> & {
    state: U;
}; };
export declare const createActions: <T extends Record<string, (...params: any[]) => Record<string, unknown>>>(actions: T) => (dispatch: React.Dispatch<{ [U in keyof T]: ReturnType<T[U]> & {
    type: U;
}; }[keyof T]>) => { [U_1 in keyof T]: (...params: Parameters<T[U_1]>) => void; };
export declare type StatesUnion<T extends Record<string, (...params: any[]) => any>> = ReturnType<T[keyof T]>;
export declare type ActionsUnion<T extends (dispatch: Dispatch<any>) => any> = Parameters<T>[0] extends Dispatch<infer A> ? A : never;
export interface IAction {
    type: string;
}
declare type TMatch<S extends IState, R = any> = {
    [SS in S['state']]: (state: S & {
        state: SS;
    }) => R;
};
declare type TPartialMatch<S extends IState, R = any> = {
    [SS in S['state']]?: (state: S & {
        state: SS;
    }) => R;
};
export declare type PickState<S extends IState, T extends S['state'] = never> = [T] extends [never] ? S : S extends {
    state: T;
} ? S : never;
export declare type PickAction<A extends IAction, T extends A['type']> = A extends {
    type: T;
} ? A : never;
export declare type TTransition<S extends IState, A extends IAction, SS extends S['state'] = S['state']> = {
    [AA in A['type']]?: (state: S & {
        state: SS;
    }, action: A extends {
        type: AA;
    } ? A : never) => S;
};
export declare type TTransitions<S extends IState, A extends IAction> = {
    [SS in S['state']]: TTransition<S, A, SS>;
};
declare type TReadableTransition<T extends TTransitions<any, any>> = {
    [S in keyof T]: {
        [A in keyof T[S]]: S extends string ? A extends string ? T[S][A] extends (...args: any[]) => IState ? `${S} => ${A} => ${ReturnType<T[S][A]>['state']}` : never : never : never;
    }[keyof T[S]];
}[keyof T];
export declare function transition<S extends IState, A extends IAction, T extends TTransitions<S, A>>(state: S, action: A, transitions: T): S & {
    [$ACTION]?: A;
    [$PREV_STATE]?: S;
    [$TRANSITIONS]?: TReadableTransition<T>;
};
export declare function useEnter<S extends IState, SS extends S['state'] | S['state'][]>(state: S, states: SS, effect: (current: SS extends string[] ? S & {
    state: SS[number];
} : SS extends string ? S & {
    state: SS;
} : never) => void | (() => void), deps?: unknown[]): void;
export declare function useTransition<S extends IState, T extends S[typeof $TRANSITIONS] | S[typeof $TRANSITIONS][]>(state: S, transition: T, effect: T extends `${infer SP} => ${infer A} => ${infer SC}` | `${infer SP} => ${infer A} => ${infer SC}`[] ? (current: S & {
    state: SC;
}, action: Exclude<S[typeof $ACTION], undefined> & {
    type: A;
}, prev: S & {
    state: SP;
}) => void | (() => void) : never, deps?: unknown[]): void;
export declare function useTransition<S extends IState>(state: S, effect: (current: S, action: Exclude<S[typeof $ACTION], undefined> | undefined, prev: S | undefined) => void | (() => void), deps?: unknown[]): void;
export declare function match<S extends IState, T extends TMatch<S>>(state: S, matches: T): {
    [K in keyof T]: T[K] extends (...args: any[]) => infer R ? R : never;
}[keyof T];
export declare function match<S extends IState, T extends TPartialMatch<S>, U>(state: S, matches: T, _: (state: S & {
    state: Exclude<S['state'], keyof T>;
}) => U): {
    [K in keyof T]: T[K] extends (...args: any[]) => infer R ? R : never;
}[keyof T] | U;
export declare function matchProp<S extends IState, P extends {
    [K in keyof S]: keyof (S & {
        state: K;
    });
}[keyof S]>(state: S, prop: P): S extends Record<P, unknown> ? S : undefined;
export declare const managerContext: React.Context<Manager>;
export declare const useDevtools: (id: string, reducer: [any, any]) => [any, any];
export {};
